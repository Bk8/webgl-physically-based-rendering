<!DOCTYPE html>
<html>
    <head>
        <title>WebGL Physically Based Rendering</title>
    </head>
    <body>
        <!-- Canvas for rendering WebGL image. -->
        <canvas id="webgl-canvas" width="1280" height="720"></canvas>

        <!-- All the code for interfacing with GLSL with JavaScript. -->

        <!-- Vertex shader code. -->
        <script id="vertex-shader" type="x-shader/x-vertex">

            attribute vec3 AVertexPosition;
            attribute vec3 AVertexNormal;
            attribute vec2 ATextureCoord;

            uniform bool USkybox;
            uniform vec4 UCamPosition;
            uniform vec4 ULightPosition;
            uniform mat4 UMatModel, UMatView, UMatProj;
            uniform mat4 UMatNormal;

            varying vec3 L, N, E;
            varying vec3 VPosEye;
            varying vec3 VTextureCoordSkybox;

            void main(void) {

                // Calculate the position and normals to pass into the fragment shader.
                vec3 PosTransform = vec3(UMatView * UMatModel * vec4(AVertexPosition, 1.0));
                vec3 NormTransform = vec3(UMatView * UMatModel * vec4(AVertexNormal, 0.0));
                vec3 LightTransform = (UMatView * ULightPosition).xyz;

                // Calculate environment mapping variables.
                VPosEye = normalize(PosTransform);

                L = normalize(LightTransform - PosTransform);
                N = normalize(NormTransform);
                E = normalize(-PosTransform);

                if (USkybox)
                {
                    VTextureCoordSkybox = AVertexPosition;
                }

                gl_Position = UMatProj * UMatView * UMatModel * vec4(AVertexPosition, 1.0);
            }

        </script>

        <!-- Fragment shader code. -->
        <script id="fragment-shader" type="x-shader/x-fragment">

            precision mediump float;

            uniform bool USkybox;
            uniform vec4 UAmbientProduct, UDiffuseProduct, USpecularProduct;
            uniform samplerCube USamplerCube;
            uniform mat4 UMatCameraRot;
            uniform mat4 UMatViewInv;

            varying vec3 L, N, E;
            varying vec3 VPosEye;
            varying vec3 VTextureCoordSkybox;
            varying vec4 VColor;

            void main(void) {
                // Calculate the color/intensities of each respective light.
                vec4 ColorAmbient, ColorDiffuse, ColorSpecular, VColor;

                // Ambient light.
                ColorAmbient = UAmbientProduct;
                
                // Diffuse light.
                ColorDiffuse = max(dot(L, N), 0.0) * UDiffuseProduct;
                
                // Specular light.
                vec3 H = normalize(L + E);
                ColorSpecular = max(pow(max(dot(H, N), 0.0), 100.0) * USpecularProduct, 0.0);

                // Add all the lights up.
                VColor = ColorAmbient + ColorDiffuse + ColorSpecular;
                VColor.a = 1.0;

                vec3 LightReflected = reflect(VPosEye, N);
                // LightReflected = vec3(UMatCameraRot * vec4(LightReflected, 0.0));
                LightReflected = vec3(UMatCameraRot * UMatViewInv * vec4(LightReflected, 0.0));
                VColor = textureCube(USamplerCube, LightReflected);
                VColor.a = 1.0;

                if (USkybox)
                {
                    VColor = vec4(0.4, 0.2, 0.2, 1.0);
                    VColor = textureCube(USamplerCube, VTextureCoordSkybox);
                }

                gl_FragColor = VColor;
            }

        </script>

        <script type="text/javascript" src="javascript/webgl-utils.js"></script>
        <script type="text/javascript" src="javascript/glmathlib.js"></script>
        <script type="text/javascript" src="javascript/mesh.js"></script>
        <script type="text/javascript" src="javascript/main.js"></script>
    </body>
</html>